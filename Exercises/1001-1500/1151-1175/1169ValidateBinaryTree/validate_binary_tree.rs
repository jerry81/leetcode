/*

98. Validate Binary Search Tree
Medium
Topics
Companies
Given the root of a binary tree, determine if it is a valid binary search tree (BST).

A valid BST is defined as follows:

The left
subtree
 of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.


Example 1:


Input: root = [2,1,3]
Output: true
Example 2:


Input: root = [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.


Constraints:

The number of nodes in the tree is in the range [1, 104].
-231 <= Node.val <= 231 - 1
Seen this question in a real interview before?
1/5
Yes
No
Accepted
2.6M
Submissions
7.8M
Acceptance Rate
33.7%

*/

// Definition for a binary tree node.
#[derive(Debug, PartialEq, Eq)]
/*
In Rust, the #[derive] attribute is used to automatically implement
 certain traits for a struct or enum. This is particularly useful for
 reducing boilerplate code, as it allows you to get common functionality
 without having to manually implement the traits yourself.

 these three are generated by rust
*/
pub struct TreeNode {
  pub val: i32,
  pub left: Option<Rc<RefCell<TreeNode>>>,
  pub right: Option<Rc<RefCell<TreeNode>>>,
}

impl TreeNode {
  #[inline]
  /*
  The #[inline] attribute in Rust is a hint to the
  compiler that you would like it to consider inlining the
  function where it is called. Inlining is an optimization
  technique where the function's code is directly inserted
  into the calling code, rather than being called through the
  usual function call mechanism. This can lead to performance
  improvements by eliminating the overhead of a function call,
  especially for small, frequently called functions
  */
  pub fn new(val: i32) -> Self {
    TreeNode {
      val,
      left: None,
      right: None
    }
  }
}
use std::rc::Rc;
/*
Rc stands for "Reference Counted" and is a type in Rust
that enables multiple ownership of data. It is part of the
standard library and is used for shared ownership of a value.
Hereâ€™s a brief overview of how Rc works:

diff from &mut - single ownership vs multiple ownership

ownership governs how memory is accessed - handles things like garbage collection
*/

use std::cell::RefCell;
/*
RefCell is a type in Rust that provides interior mutability,
allowing you to mutate data even when it is behind an immutable reference.
It is part of the std::cell module and is particularly useful in scenarios
where you need to share data across multiple owners while still allowing
for mutable access.
*/

impl Solution {
  pub fn is_valid_bst(root: Option<Rc<RefCell<TreeNode>>>) -> bool {
    if let Some(node) = root { // check if root is Some then assign node
      let borrowed = node.borrow(); // unwrap for refcell/rc or option? borrow provided by RefCell
      let value = borrowed.val;
      if let Some(ln) = borrowed.left {
        if ln.borrow().val >= value { return false }
      }
      if let Some(rn) = borrowed.right {
        if rn.borrow().val <= value { return false }
      }
      Solution::is_valid_bst(&borrowed.left.as_ref()) && Solution::is_valid_bst(&borrowed.right.as_ref());
    } else {
      true
    }
  }
}